using PauliOperators
using UnitaryPruning
using QuantumChemQC
using Tullio
using Printf
using IterTools
using LinearAlgebra
using Printf

"""
  In this tests we will implement a complete evaluation of the energy for H2 using an ADAPT-VQE 
  approach based on PP, we follow the original strategy of Grimsley et al.
  https://www.nature.com/articles/s41467-019-10988-2/figures/1

  To this end we consider the following steps:
    1) Define the molecule and run an SCF to get the integrals and Qubit Hamiltonian
    2) Define the operrator pool consisting on 1 and 2 body qubit excitation operators
    3) Compute the gradients of each operator in the pool with respect to the initial state
    4) Select the operator with the largest gradient and add it to the ansatz
    5) Optimize the ansatz parameters to minimize the energy
    6) Repeat from step 3 until convergence is reached

   In the Heisenberg picture, the Hamiltonian is evolved as:
       H' = U† H U
   where U = ∏_j exp(i θ_j G_j) is the unitary operator generated by the ansatz operators G_j and parameters θ_j.
   Our generators are the operators in the pool, and the parameters are the angles associated to each operator.
    
   The energy is then computed as:
         E = <ψ| H' |ψ>
    where |ψ> is the initial state (e.g., Hartree-Fock state).

   However, the gradients are computed as:
         dE/dθ_k = <ψ| [i G_k, H'] |ψ>
    which can be evaluated using the commutator of the generator G_k with the evolved Hamiltonian H'.
"""

# # # # # # # # # F U N C T I O N S # # # # # # # # # # #

"""
 Functions for the evolution of the Hamiltonian using a full evolution (no pruning)
"""
function newclip!(ps::PauliSum{N}; thresh=1e-16) where {N}
    filter!(p->(abs(p.second) ≥ thresh) , ps)
end

function evolve_full(P::Union{PauliSum{N, T}, Pauli{N}}, generators::Vector{Pauli{N}}, params::Vector{Float64}, dt) where {N, T}
# We want to do  ∑_j [∏e^(iθG)] c_jP_j [∏e^(-iθG)]
    out =  PauliSum(N)
    
    # display(params)
    nt = length(params)
   
    o_transformed = deepcopy(P)

    for t in 1:nt
        g = generators[t]
        
        println("Phase in generator $g: $(g.s) ")
        sin_branch = PauliSum(N)
        
        for (o, o_coeff) in o_transformed
            
            if PauliOperators.commute(o, PauliBasis(g)) == false

                    # cos branch
                    o_transformed[o] = o_coeff * cos( params[t])

                    # sin branch
                    #oj = g * o
                    sum!(sin_branch, 1im * o_coeff * o * g * sin( params[t]) )

                end
            end
            sum!(o_transformed, sin_branch)
            newclip!(o_transformed, thresh=1e-10)
        end
        sum!(out, o_transformed)
    return out
end

"""
  Function returnign the Hamiltonian for H2 at a given interatomic distance
    d -> The interatomic distance
"""
function H2_hamiltonian_diss(d)
    mol = """
    0 1
    H  0.0000   0.000  0.000
    H  0.0000   0.000  $d
    """

    bset, p = QuantumChemQC.molecule(mol, "sto-3g", spherical = false)
    scf_obj = QuantumChemQC.SCF(mol, bset, p)

    # Atomic integrals
    ao_hcore = scf_obj.T + scf_obj.V
    ao_eris = scf_obj.I

    # Transform Atomic integrals into Molecular integrals
    C = scf_obj.C # MO coeffs
    mo_hcore , mo_eris = QuantumChemQC.ao2mo_coefficients(C, ao_hcore, ao_eris)

    # Spinorbital tensors
    core =0 
    h0 = scf_obj.Enuc + core 
    h1, h2 = QuantumChemQC.get_spin_orbital_tensors(mo_hcore, mo_eris)
    N = size(h1, 1)
    qubit_paulis, qubit_coeffs = QuantumChemQC.qubit_hamiltonian(N, h0, h1, h2) 

    gen, coeff = QuantumChemQC.combine_terms(qubit_paulis, qubit_coeffs)
return gen, coeff, N;
end

"""
 The following function computes the gradients of the energy computed as the expectation value of a commutator
  < [H, A] > with respect to a state |psi>
  H -> Hamiltonian as a PauliSum
  A -> Operator as a Pauli
  psi -> State as a Ket
"""
function energy_gradient(H::PauliSum{N}, A::Pauli{N}, psi::Ket) where N
    # collect our results here...
    expval = zero(ComplexF64)
    commutator = PauliSum(N)

    for (h, c) in H
        if !PauliOperators.commute(h, PauliBasis(A))
            comm = 2 * h * A # This includes the correct ±i phase
            #println("Commutator of $h and $A is: ")
            #display(comm)
            sum!(commutator, c * d * comm)
        end
    end

    #println("The full commutator is: ")
    #display(commutator)
    #println("- - - - - - - - - - - - - ")
    #println("Now computing the expectation value of the commutator...")
    for (oi, coeff) in commutator
        expval += coeff * PauliOperators.expectation_value(oi, psi)
   #     println("Expectation value of the commutator is: $expval")
    end
    return imag(expval)
end


"""
 "Cost function" for the ADAPT-VQE with PP
  This function computes the energy expectation value of the evolved Hamiltonian with respect to the initial state  
"""
function cost_energy(Op::PauliSum{N}, coeffs::Vector{Float64},ket::Ket) where N
   e = PauliOperators.expectation_value(Op, ket)
  return e
end


#
# # # # # # Main program # # # # # #
#

# 1) Define the molecule and run an SCF to get the integrals and Qubit Hamiltonian
println("= = = = = = = = ADAPT-VQE with PP = = = = = = = ")
println("Molecule and Hamiltonian definition")
d = 0.74
H_terms, H_coeffs, N_qubits = H2_hamiltonian_diss(d)
ket = Ket(N_qubits, 3) #HF STATE

# Display the initial state
println("Initial Hartree-Fock state |ψ⟩:")
display(ket)

H_op = PauliSum(N_qubits)
for (p,c) in zip(H_terms, H_coeffs)
    global H_op += c * p
end

println("Hamiltonian as PauliSum:")
display(H_op)
rhf_energy = PauliOperators.expectation_value(H_op, ket)
println("HF Energy is: $rhf_energy")
println("- - - - - - - - - - - - - - - - - - - - - - - - ")
# 2) Define the operator pool consisting on 1 and 2 body qubit excitation operators

pool, pool_coeffs = ADAPT_PP.base.qubitexcitationpool(N_qubits)
println("Pool generated with $(length(pool)) operators.")
println(typeof(pool))
for p in pool
    display(p)
end

println("- - - - - - - - - - - - - - - - - - - - - - - - ")
# 3) Initialize and Compute the gradients of each operator in the pool with respect to the initial state
cycle = 0
e0 = PauliOperators.expectation_value(H_op, ket)
println(" Cycle: $cycle | Energy: $e0 ")


println("- - - - - - - - - - - - - - - - - - - - - - - - ")
# 4) Select the operator with the largest gradient and add it to the ansatz
# Measure gradients
#Create a dictionary to store the gradients and associated operators
gradients = Dict{Any, ComplexF64}()

for p in pool
    grad = energy_gradient(H_op, p, ket)
    gradients[p] = grad # Store the gradient associated to the operator
    #println("Gradient for operator $p is: $grad")
end

sorted_grads = sort(collect(gradients), by=x->-abs(x[2])) # Sort by absolute value of the gradient
max_op, max_grad = sorted_grads[1] # Get the operator with the largest gradient
println("Operator with the largest gradient: $max_grad")
display(max_op)

push!(pool_coeffs, 1.0) # Initial coefficient for the selected operator
push!(pool, max_op)

# Perform evolution of the Hamiltonian with the selected operator
# This must be equivalent to growing the ansatz with the selected operator
evol_op = UnitaryPruning.bfs_evolution_vqe(pool, pool_coeffs, H_op, thresh=1e-6)
println("Evolved Hamiltonian after Unitary Pruning:")
display(evol_op)

println("- - - - - - - - - - - - - - - - - - - - - - - - ")
# Check expectation value and convergence
e1 = PauliOperators.expectation_value(evol_op, ket)
cycle += 1
println(" Cycle: $cycle | Energy: $e1 ")

# 5) Re-Optimize all parameters to minimize the energy
# REDO
# 6) Repeat from step 3 until convergence is reached

##############
gradients = Dict{Any, ComplexF64}()

for p in pool
    grad = energy_gradient(evol_op, p, ket)
    gradients[p] = grad # Store the gradient associated to the operator
    #println("Gradient for operator $p is: $grad")
end

sorted_grads = sort(collect(gradients), by=x->-abs(x[2])) # Sort by absolute value of the gradient
max_op, max_grad = sorted_grads[1] # Get the operator with the largest gradient
println("Operator with the largest gradient: $max_grad")
display(max_op)

push!(pool_coeffs, 1.0) # Initial coefficient for the selected operator
push!(pool, max_op)

# Perform evolution of the Hamiltonian with the selected operator
# This must be equivalent to growing the ansatz with the selected operator
evol_op = UnitaryPruning.bfs_evolution_vqe(pool, pool_coeffs, evol_op, thresh=1e-6)
println("Evolved Hamiltonian after Unitary Pruning:")
display(evol_op)

println("- - - - - - - - - - - - - - - - - - - - - - - - ")
# Check expectation value and convergence
e1 = PauliOperators.expectation_value(evol_op, ket)
cycle += 1
println(" Cycle: $cycle | Energy: $e1 ")

##############
gradients = Dict{Any, ComplexF64}()

for p in pool
    grad = energy_gradient(evol_op, p, ket)
    gradients[p] = grad # Store the gradient associated to the operator
    #println("Gradient for operator $p is: $grad")
end

sorted_grads = sort(collect(gradients), by=x->-abs(x[2])) # Sort by absolute value of the gradient
max_op, max_grad = sorted_grads[1] # Get the operator with the largest gradient
println("Operator with the largest gradient: $max_grad")
display(max_op)

push!(pool_coeffs, 1.0) # Initial coefficient for the selected operator
push!(pool, max_op)

# Perform evolution of the Hamiltonian with the selected operator
# This must be equivalent to growing the ansatz with the selected operator
evol_op = UnitaryPruning.bfs_evolution_vqe(pool, pool_coeffs, evol_op, thresh=1e-6)
println("Evolved Hamiltonian after Unitary Pruning:")
display(evol_op)

println("- - - - - - - - - - - - - - - - - - - - - - - - ")
# Check expectation value and convergence
e1 = PauliOperators.expectation_value(evol_op, ket)
cycle += 1
println(" Cycle: $cycle | Energy: $e1 ")